This chapter provides a detailed architectural design of Students\&Companies, starting with a high-level overview of the system's design choices and their rationale.
It then explores the component view, illustrating major system modules and their interactions using various UML diagrams.
A deployment view follows, showing how software components distribute across hardware nodes.
Runtime views are then presented through sequence diagrams depicting key system operations.
The chapter concludes with a discussion of chosen architectural styles, patterns and other significant design decisions.

\section{Overview}
Students\&Companies requires an architecture that can efficiently handle the complex interactions between students, companies and universities while ensuring system scalability and data security.
The platform adopts a three-tier client-server architecture, separating presentation, application logic and data management into distinct layers.
This section provides an overview of the application of this architecture to the problem at hand, while a more general discussion of patterns and styles belongs in later sections.

\subsubsection{Client Tier}
At the client tier, the web app serves as the user interface, allowing students, companies and universities to access S\&C through their browsers.
The app is designed to be responsive, ensuring accessibility across various devices while maintaining a consistent user experience.

\subsubsection{Middle Tier}
The middle tier consists of three server components.

The web server handles incoming client requests, managing user sessions and providing load balancing capabilities to distribute traffic effectively across multiple instances of the application server.
The AS contains the core business logic, processing user requests to coordinating the entire internship lifecycle from application to completion.

The mail server manages the email workflow, determining when to send notifications for registration confirmations, new matches, selection updates or internship comments.
For actual email delivery, the MS integrates with an external email provider that handles the delivery infrastructure, ensuring reliable communication reaches users' inboxes.

\subsubsection{Data Tier}
The data tier employs a DBMS server to store and manage all system data.
This includes user profiles, internship positions, ongoing matches, selection processes and internship records.
The DS provides structured data storage with built-in mechanisms for maintaining data integrity through transaction management and constraint enforcement, optimizing query performance through indexing and caching, and implementing access controls and encryption for sensitive user data.

Overall, this architecture enables efficient data flow while maintaining scalability and security.
When a user interacts with the WA, their request flows through the WS to one of the AS instances, which processes it using data from the DS and triggers notifications through the MS when necessary.

\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{images/architecture.png}
    \caption{Architecture overview}
\end{figure}

\section{Component View}
\subsection{High Level Diagram}
\subsection{Low Level Diagram}
\subsection{Managers}
\section{Deployment View}
\section{Runtime View}
\section{Component Interfaces}
\section{Architectural Styles and Patterns}
This section examines the architectural styles adopted in Students\&Companies, explaining their general principles and how they guide implementation decisions.
Understanding these foundational choices is crucial for developers working on the system, as they influence everything from component interaction to code organization.

\subsubsection{Client-Server Architecture}
The system's foundation rests on a client-server architecture, which separates systems into service requesters, called clients, and service providers, called servers.
This separation enables the user interface to evolve independently from data processing and storage, while centralizing resource management on the server side.
Developers can thus focus on their specific domain, either crafting responsive user experiences or implementing robust server-side logic.

Modern applications refine this pattern through tiers, logical groupings of related functionality.
A three-tier architecture divides the application into three distinct layers: a presentation tier that handles the user interface, a business logic tier that processes application rules and a data tier that manages storage.
This separation gives developers clear boundaries for their work.
Interface developers can update the presentation tier without considering database queries.
Application developers can enhance business logic without touching the user interface.
Database administrators can optimize storage without impacting other tiers.
Each team works independently, reducing development bottlenecks and simplifying maintenance.

\subsubsection{REST Architecture}
REST (Representational State Transfer) guides how these tiers communicate over the web.
Originally conceived for document transfer, REST has evolved into a comprehensive style for data exchange.
Its core principle of statelessness means that servers maintain no information about past requests.
In turn, each client request must contain all necessary context.
This architectural choice significantly impacts development: backend developers need not manage complex session states, system administrators benefit from straightforward load balancing since any server can handle any request and cache developers can optimize performance by focusing solely on request parameters rather than server state.

\subsubsection{Event-Driven Architecture}
The system also employs an event-driven architecture, organizing certain components around event production and consumption rather than direct coupling.
When a company posts a new internship position, for example, the system generates an event rather than directly notifying students.
This architectural choice lets developers add new features without modifying existing code, as they simply subscribe new components to relevant events.
The pattern particularly shines in notifications and real-time updates, providing a clean separation between event producers and consumers.

\section{Other Design Decisions}
While architectural patterns provide the system's foundation, many other critical design decisions shape its implementation.
This section outlines these choices, focusing on practical aspects that developers must consider when maintaining or extending the system.

\subsubsection{Deployment Approach}
The deployment strategy embraces horizontal scaling, running multiple application server instances rather than scaling up individual servers.
This approach requires developers to write stateless code that works across instances, but provides significant benefits: the system continues functioning even if some instances fail, resource allocation becomes more flexible as administrators can add or remove instances based on demand and load balancing becomes straightforward since any instance can handle any request.

\subsubsection{Security Implementation}
Security permeates every aspect of the design through multiple complementary layers.
All client-server communication uses HTTPS encryption, protecting data in transit.
Sensitive user information receives additional encryption in the database.
Session management relies on secure, time-limited authentication tokens rather than storing session data server-side.
These decisions guide security-related development work, from implementing proper token handling to ensuring sensitive data never appears in logs.

\subsubsection{Data Management}
Data management emphasizes both integrity and performance.
The database implements transaction management to maintain consistency even during concurrent operations.
Constraint enforcement at the database level catches data validity issues early.
Performance optimization through strategic indexing and caching improves response times.
These choices influence how developers interact with data, as they must properly manage transactions, respect constraints and consider query performance during development.
